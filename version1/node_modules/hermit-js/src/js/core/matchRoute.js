
import parseParams from './parseParams';
import utils from './utils';

let routes = [];

export default {

	configure(_routes){
		// Force array on routes
        _routes = ( typeof _routes === "string" ) ? [ _routes ] : _routes;
        routes = routes.concat( this._cleanRoutes( _routes ) );

        return this;
	},

	test(url){
		return this.parse( url, routes );
	},

	parse(url, routes){

		var segMatches,
			isStar,
			params,
			match,
			route = this._cleanRoute( url ),
			ruris,
			regex,
			cond,
			uris = route.split( "/" ),
			uLen = uris.length,
			iLen = routes.length,
			ret;

		for ( var i = 0; i < iLen; i++ ) {
			// Flag "*" route
			isStar = (routes[ i ] === "*");

			// Start fresh each iteration
			// Only one matched route allowed
			ret = {
				matched: false,
				route: null,
				uri: [],
				params: {},
				query: parseParams( url )
			};

			ruris = routes[ i ].split( "/" );

			// Handle route === "/"
			if ( route === "/" && routes[ i ] === "/" ) {
				ret.matched = true;
				ret.route = routes[ i ];
				ret.uri = "/";

				break;
			}

			// If the actual url doesn't match the route in segment length,
			// it cannot possibly be considered for matching so just skip it
			if ( ruris.length !== uris.length && !isStar ) {
				continue;
			}

			segMatches = 0;

			for ( var j = 0; j < uLen; j++ ) {
				// Matched a variable uri segment
				if ( utils._rWild.test( ruris[ j ] ) ) {
					// Try to split on conditions
					params = ruris[ j ].split( "!" );

					// The variable segment
					match = params[ 0 ];

					// The match condition
					cond = params[ 1 ];

					// With conditions
					if ( cond ) {
						// We support this condition
						if ( utils._wilders[ cond ] ) {
							regex = utils._wilders[ cond ];
						}

						// Test against the condition
						if ( regex && regex.test( uris[ j ] ) ) {
							segMatches++;

							// Add the match to the config data
							ret.params[ match.replace( utils._rWild, "" ) ] = uris[ j ];
							ret.uri.push( uris[ j ] );
						}

					// No conditions, anything goes
					} else {
						segMatches++;

						// Add the match to the config data
						ret.params[ match.replace( utils._rWild, "" ) ] = uris[ j ];
						ret.uri.push( uris[ j ] );
					}

				// Defined segment always goes
				} else {
					if ( uris[ j ] === ruris[ j ] ) {
						segMatches++;

						ret.uri.push( uris[ j ] );
					}
				}
			}

			// Handle a uri segment match OR "*" wildcard everything
			if ( segMatches === uris.length || isStar ) {
				ret.matched = true;
				ret.route = routes[ i ];
				ret.uri = ( isStar ) ? route : ret.uri.join( "/" );

				break;
			}
		}

		return ret;
	},

	_cleanRoute(route){

		if( route != '/' ){
			route = route.replace( utils._rHTTPs, "" );
			route = route.replace( utils._rTrails, "" );
			route = route.replace( utils._rHashQuery, "" );
			route = route.replace( utils._rTrails, "" );
		}

		if( route === '' ){
			route = '/';
		}

		return route;
	},

	_cleanRoutes(_r){

		for ( var i = _r.length; i--; ) {
			_r[ i ] = this._cleanRoute( _r[ i ] );
		}

		return _r;
	}
}
