
import App from './index';

import matchRoute from './core/matchRoute';
import matchElement from './core/matchElement';
import pageController from './controllers/pageController';
import DataController from './controllers/dataController';

import * as core from './core';
import log from './core/log';
import merge from './core/merge';

let _routes = {};

export default {

	init(opts){

		log('Router Init');
		log('warn', 'Router :: TODO :: Update nav');
		log('warn', 'Router :: TODO :: Show optional loader if waiting too long');

		this.options   = opts;
		this.isRouting = false;

		matchRoute.configure(this.options.routes);

		this.dataController = new DataController({
			cache: this.options.cache,
			baseUrl: this.options.baseUrl,
			adapter: this.options.adapter,
			proxy: this.options.proxy
		});

		this._addListeners();
	},

	config(opts){
		this.options = merge({}, this.options, opts);
	},

	start(){
		if( this.options.runFirstRoute ){
			let url = window.location.pathname;
			let match = matchRoute.test(url);
			this._route(match, false);
		}
	},

	_addListeners(){

		let self = this;

		this.onDocumentClick = this.onDocumentClick.bind(this);
		this.onPopstate      = this.onPopstate.bind(this);

		document.addEventListener('click', function(e){
			self.onDocumentClick(this, e);
		});

		window.addEventListener('popstate', this.onPopstate);
	},

	_route(match, updateUrl){

		this.isRouting = true;
		core.dom.main.addClass('is-routing');

		let startTime = new Date();

		if( updateUrl ){
			// Home page is always '/'
			let uri = match.uri == '/' ? '' : match.uri;
			core.utils.pushState(this.options.baseUrl + uri);
		}

		if( this.options.async ){

			this.dataController.getData(match)
				.then((data)=>{

					let finishTime = new Date();
					let timeElapsed = finishTime - startTime;
					let delay = (timeElapsed < this.options.transitionDuration) ? this.options.transitionDuration - timeElapsed : 0;

					setTimeout(()=>{
						this.isRouting = false;
						pageController.renderPage(data, match);
						this.triggerRoutes(match, data);
						core.dom.main.removeClass('is-routing');
					}, delay);
				})
				.catch((err)=>{
					core.log('error', err);
				});
		}
		else {
			setTimeout(()=>{
				this.isRouting = false;
				this.triggerRoutes(match);
				core.dom.main.removeClass('is-routing');
			}, this.options.transitionDuration);
		}
	},

	triggerRoutes(match, data = {}){
		if( _routes[ match.route ] ){
			for( let i = 0; i < _routes[ match.route ].length; i ++ ){
				_routes[ match.route ][ i ].call(null, match, data);
			}
		}
	},

	// listener methods

	onPopstate(){
		let url = window.location.pathname;
		let match = matchRoute.test(url);
		this._route(match, false);
	},

	onDocumentClick(el,e){

		var elem = (matchElement( el, "a", true ) || matchElement( e.target, "a", true )),
			isMatched = elem && matchRoute.test( elem.href ),
			isDomain = elem && core.utils._rDomain.test( elem.href ),
			isProxy = elem && this.options.proxy,

			isHashed = elem && elem.href.indexOf('#') !== -1,
			isIgnore = elem && elem.hasAttribute('data-router-ignore'),
			isMetaKey = elem && e.metaKey,
			isBlank = elem && elem.target === '_blank',
			isFile = elem && isDomain && elem.href.match( core.utils._rFiles );

		// 0.1 => Ensure url passes MatchRoute config
		// 0.2 => Ensure url is on the Document's Domain
		if ( isProxy || isMatched && isDomain ) {
			// 0.3 => Ensure url is not a #hash
			// 0.4 => Ensure the element does not contain a `js-router--ignore` className
			// 0.5 => Ensure the Event.metaKey is not TRUE - Command+click
			// 0.6 => Ensure the element target is not for a new tab
			// 0.7 => Ensure url is not a file link on the same document domain
			if ( !isHashed && !isIgnore && !isMetaKey && !isBlank && !isFile ) {

				e.preventDefault();

				if ( !this._isRouting ) {
					this._route( isMatched, true );
				}
			}
		}
	},

	// public

	navigate(url, silent){

		let matched = matchRoute.test(url);

		if( matched ){
			this._route(matched, silent);
		}
	},

	// add a route and a callback
	addRoute(route, callback){

		matchRoute.configure(route);

		let config = matchRoute.test(route);

		if( !_routes[ config.route ] ){
			_routes[ config.route ] = [];
		}

		if( callback ){
			_routes[ config.route ].push(callback);
		}
	},

	// assign an adapter to the datacontroller instance
	use(adapter){
		this.dataController.use(adapter);
	}
}
